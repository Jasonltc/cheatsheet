<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Cheat code page</title>
    <style>
      * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
        font-family: sans-serif;
      }

      body {
        padding: 30px;
        max-width: 1440px;
        margin: 0 auto;
      }

      .grid-form {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 30px 50px;
      }

      h2 {
        margin: 30px 0;
      }

      h3 {
        text-decoration: underline;
        margin-bottom: 20px;
      }

      section {
        padding: 15px;
        border: 1px solid;
      }

      p {
        line-height: 30px;
        margin-bottom: 20px;
        margin-left: 10px;
        position: relative;
      }

      p::before {
        content: "";
        position: absolute;
        left: -10px;
      }

      hr {
        margin: 50px 0;
      }

      .code-color {
        color: red;
      }

      @media screen and (min-width: 300px) and (max-wi) {
      }
    </style>
  </head>
  <body>
    <h2>Fundamental Part 1</h2>
    <div class="grid-form">
      <section>
        <h3>General</h3>
        <p>for(let i = 0; i < 6; i ++) { will return 6 digit }</p>
        <p>use forEach() method with the event method to see which we target</p>
        <p>DOMContentLoaded</p>
      </section>
    </div>

    <hr />

    <h2>Fundamental Part 1</h2>
    <div class="grid-form">
      <section>
        <h3>Type Conversion and Coercion</h3>
        <p>
          Convert to number => example const inputYear = '1991'
          console.log(Number(inputYear));
        </p>

        <p>Convert to string => String(1); => outcome '1'</p>

        <p>
          Coercion: '1' + 1 = 11 => + convert to string '10' - 1 = 9 <br />
          => Note: always convert to number first;
        </p>
      </section>

      <section>
        <h3>Truthy and Falsy Values</h3>
        <p>Falsy values: [ 0, '', undefined, null, Nan ] => boolean false</p>
      </section>

      <section>
        <h3>Equality Operators</h3>
        <p>=== compare value and type</p>
        <p>== equal to the value</p>
      </section>

      <section>
        <h3>Boolean Logic</h3>
        <p>|| => or</p>
        <p>&& => AND</p>
      </section>

      <section>
        <h3>Statement and Expression</h3>
        <p>Expressions => produce value => for example : 1 + 3</p>
        <p>
          Statement => does not produce value itself => example if statement
        </p>
      </section>

      <section>
        <h3>The conditional (Ternary)</h3>
        <p>const age = 23</p>
        <p>
          age >= 18 ? console.log('I like to drink wine') : console.log('I'm
          still under age')
        </p>
      </section>

      <section>
        <h3>Use Strict mode</h3>
        <p>'use strict'</p>
      </section>
    </div>

    <hr />

    <h2>Fundamental Part 2</h2>
    <div class="grid-form">
      <section>
        <h3>Function</h3>
        <p>A piece of code where we can reuse again and again</p>
        <p>Example => function logger(Parament1, Parament2){ code here };</p>
        <p>
          In a function if we want to return a value. - we need to store it
          first
          <br />
          for example => const juice = logger() => console.log(juice);
        </p>
      </section>

      <section>
        <h3>Function Declarations vs Expression</h3>
        <p>
          Example function declarations example <br />
          function calcAge1(){};
        </p>
        <p>
          Example function expression example <br />
          let calcAge = function(){};
        </p>
      </section>

      <section>
        <h3>Arrow function</h3>
        <p>Arrow function example => let arrowFunction = () => {}</p>
        <p>
          'This' in arrow function does not exist and is refer to the window
          object
        </p>
      </section>

      <section>
        <h3>Functions calling other functions</h3>
      </section>

      <section>
        <h3>Introduction to Arrays</h3>
        <p>Example => const first = [ 'Michael', 'Harry', 'Peter' ]</p>
        <p>Other way => const years = new Array();</p>
      </section>

      <section>
        <h3>Basic Array Operations ( Methods )</h3>

        <p>
          Friends.push => add a new value in the place position => modified the
          original arrow => return the length of the arrow
        </p>

        <p>Friends.unshift => add a new value in the first position</p>
        <p>Friends.shift => remove the first value</p>
        <p>
          Friends.pop => remove the last value => modified the original arrow =>
          return the value remove
        </p>
        <p>Friends.length</p>
        <p>Friends.slice</p>
        <p>Friends.includes('Jack')</p>
        <p>Friends.indexOf('Harry')</p>
      </section>

      <section>
        <h3>Introduction to object</h3>
        <p>Key value pair</p>
        <p>
          Example of an object => const jonas = { name:'Jason', age:23.
          'job':'web developer' }
        </p>
      </section>

      <section>
        <h3>Dot vs Bracket Notation</h3>
        <p>jonas.name</p>
        <p>or jonas['name'] in [] we can put any expression</p>
      </section>

      <section>
        <h3>Object Methods</h3>
        <p>
          In the object => calcAge: function (birthYear) {return 2037 -
          birthYear}
        </p>
      </section>

      <section>
        <h3>Iteration: The for loop</h3>
        <p>for(let rep = 0; rep <= 10; rep++){}</p>
      </section>

      <section>
        <h3>Looping Backwards and loops in loops</h3>
        <p>for(let i = friends.length - 1; i = 0; i--){}</p>

        <p>Loop in loops</p>
        <p>
          for(let i = friends.length - 1; i = 0; i--){ for(let i =
          friends.length - 1; i = 0; i--){ } }
        </p>
      </section>
    </div>

    <hr />

    <h2>Section 5: Developer Skills & Editor setup</h2>
    <div class="grid-form">
      <section>
        <h3>Prettier and vs code</h3>
        <p>menu => preferences => User Snippets ==> code the snipper there</p>
      </section>
    </div>

    <hr />

    <h2>Section 7: Javascript in the Browser: DOM and Events Fundamentals</h2>
    <div class="grid-form">
      <section>
        <h3>What's the DOM and DOM manipulation</h3>
        <p>DOM => Document Object Model</p>
      </section>
    </div>

    <hr />

    <h2>Section 8: How Javascript works Behind the scenes</h2>
    <div class="grid-form">
      <section>
        <h3>An High-level Overview of Javascript</h3>
        <p>Javascript is multi-paradigm</p>
        <p>1. procedural programming</p>
        <p>2. object-oriented programming (OOP)</p>
        <p>Functional programming (FP)</p>
        <p>
          Javascript runs in one single thread, so it can only do one thing at a
          time
        </p>
        <p>
          By using an event loop: tasks long running tasks, executes them in the
          "background", and puts them back in the main thread once they are
          finished
        </p>
      </section>

      <section>
        <h3>The Javascript Engine and runtime</h3>
        <p>Engine => have one Call Stack and a Heap</p>
        <p>Call stack is where the code is executed</p>
        <p>Heap store all object and memory</p>
        <p>
          JS use just in time (JIT) compilation => parsing -> compilation
          (covert to machine language) -> execution
        </p>
      </section>

      <section>
        <h3>Scope and The scope chain</h3>
        <p>Scoping => How our program's variable are organized and accessed</p>
        <p>
          Lexical Scoping => scoping is controlled by placement of function and
          block in the code
        </p>

        <p>Global scope => outside of any function block</p>
        <p>
          Local scope => variable are accessible only inside function NOT
          outside
        </p>
        <p>
          Block scope => Variable are accessible only inside block (block
          scoped) => everything that is between curly braces
        </p>

        <p>Scope Chain => Variable lookup in scope chain</p>
      </section>

      <section>
        <h3>This keyword</h3>
        <p>'This' is not static</p>
        <p>Method => this => object that is calling the method</p>
        <p>Simple function call => this => undefined</p>
        <p>
          Arrow functions => this => Does not have this => this of surrounding
          function for example parent
        </p>
        <p>
          Event Listener => this => DOM element that the handler is attached to
        </p>
      </section>

      <section>
        <h3>Primitives vs Objects (important)</h3>
        <p>
          All objects or reference type will get stored right in the memory heap
        </p>
        <p>
          On the other hand Primitives or primitives reference are stored in the
          call stack
        </p>
      </section>
    </div>

    <hr />

    <h2>section 9: Data Structures, Modern Operations and Strings</h2>
    <div class="grid-form">
      <section>
        <h3>Destructuring Array</h3>
        <p>Unpack value from an array or an object into separate variable</p>
        <p>Example:</p>
        <p>const arr = [2, 3, 4 ]</p>
        <p>const [x. y, z] = arr</p>
        <p>console.log(x, y , z) // x = 2, y = 3, z = 4</p>
        <p><b>Does not destroying the original arr</b></p>
        <p>Nested Array</p>
        <p>const nested = [2, 4, [5, 6]</p>
        <p>const [i, , [j, k]] = nested</p>
        <p>console.log(i, j, k)</p>
      </section>

      <section>
        <h3>Destructuring Objects</h3>
        <p>const {name-(property name of the object)} = object</p>
        <p>Change name</p>
        <p>{name: restaurantName, openingHours : hours} = object</p>
        <p>Nested Objects</p>
        <p>const {fri: {open, close} } = openingHours</p>
      </section>

      <section>
        <h3>The Spread Operator</h3>
        <p>Expand / unpacking element from an array</p>
        <p>const arr = [5, 4, 6 ]</p>
        <p>const badNewArr = [1, 2, 3, ...arr]</p>
        <p>console.log(badNewArr) // [ 1, 2, 3, 4, 5, 6]</p>
        <p>console.log(...badNewArr) // 1, 2, 3, 4, 5, 6</p>
        <p>Use to copy a shadow copy of an array</p>
        <p>const mainMenuCopy = [...original object]</p>
        <p>// Iterables : arrays, strings, maps, set. <b>NOT OBJECTS</b></p>
        <p>Unpack strings</p>
        <p>const str = 'jonas'</p>
        <p>const letters = [..str]</p>
        <p>console.log(letters) // ['j','o','n','a']</p>
      </section>

      <section>
        <h3>Rest Pattern and Parameters</h3>
        <p>// Spread. because on Right side of =</p>
        <p>const arr = [1, 2, ...[3, 4]</p>
        <p>// Rest, because on left side of =</p>
        <p>const [a, b, ...others] = [1, 2, 3, 4, 5]</p>
        <p>
          //The rest pattern => collect all the unused element and put it in an
          array // => always at the end of the elements
        </p>
      </section>

      <section>
        <h3>Short Circuiting (&& and || )</h3>
        <p>console.log(3 || 'Jonas')</p>
        <p>
          if the first value is a truthy one - the other value will not be
          evaluate
        </p>
        <p>Example</p>
        <p>const guest2 = restaurant.numGuests || 10 // return 10</p>
        <p>------- || -------</p>
        <p>console.log( 0 && 'Jonas')</p>
        <p>opposite of || => falsy value will be evaluated</p>
      </section>

      <section>
        <h3>The Nulish Coalescing operation ??</h3>
        <p>
          const guestCorrect = restaurant.numGuests ?? 10 - to review if forget
        </p>
      </section>

      <section>
        <h3>Logical Assignment operators</h3>
        <p>
          OR assignment operator => ||= => falsy value and will assign it to the
          2nd value
        </p>
        <p>??=</p>
        <p>&&= => => truthy value and will assign it to the 2nd value</p>
      </section>

      <section>
        <h3>Looping Arrays: The for-of loop</h3>
        <p>for (const item of [array])</p>
        <p>with index and element</p>
        <p>for (const item of menu.entries())</p>
        <p>for (const [i, el] of menu.entries())</p>
      </section>

      <section>
        <h3>Enhanced Object Literals</h3>
        <p>
          we can create a function outside of an object and put it in an object
          with the same name
        </p>
        <p>for example</p>
        <p>const myFunction = () => { code here }</p>
        <p>object { name: 'Jason' myFunction, }</p>
      </section>

      <section>
        <h3>Option Chaining (?.)</h3>
        <p>Example: console.log(restaurant.openingHours.mon?.open)</p>
        <p>
          optional chaining works +> only if the property that is before this
          question mark is true than it will be read
        </p>
        <p>can have multiple optional chaining works => ?.open?.close</p>
      </section>

      <section>
        <h3>Looping Object: object keys, Values, and Entries</h3>
        <p>for(const day of Object.keys(objectName)){} // get the object key</p>
        <p>
          for(const day of Object.values(objectName)){} // get the object value
        </p>
        <p>
          for(const day of Object.entries(objectName)){} // get the object value
        </p>
      </section>

      <section>
        <h3>Sets</h3>
        <p>Create a set</p>
        <p>const ordersSet = new Set([array])</p>
        <p>console.log (ordersSet)</p>
        <p>return a new array with no duplicate and is Iterables</p>
        <p>orderSet.size // length</p>
        <p>orderSet.has('pizza') // if it include pizza</p>
        <p>orderSet.add('') // add item in the set</p>
        <p>orderSet.delete('') // delete item in the set</p>
        <p>for (const order of orderSet) console.log(order)</p>
      </section>

      <section>
        <h3>Maps: Fundamental</h3>
        <p>
          A map is a data structure that we can use to map values to keys => any
          type of keys
        </p>
        <p>const rest = new Map();</p>
        <p>
          rest.set('name','Classico Italiano'); // add item to map => also
          return an updated map
        </p>
        <p>rest.get('name') // read the value of the map</p>
        <p>rest.has('name')</p>
        <p>rest.delete</p>
        <p>rest.size</p>
        <p>rest.clear()</p>
      </section>

      <section>
        <h3>Maps: Iteration</h3>
        <p>// convert object to map</p>
        <p>const hoursMap = new Map (object.entries(objectName))</p>
      </section>

      <section>
        <h3>Summary: Which Data structure to use</h3>
        <p>simple value => array or set</p>
        <p>key value pair => Objects or Maps</p>
      </section>

      <section>
        <h3>Working with Strings</h3>
        <p>string is like an array</p>
        <p>const airline = 'Tap Air portugal'</p>
        <p>airline.length</p>
        <p>airline.indexOf('a');</p>
        <p>airline.lastIndexOf('r');</p>
        <p>airline.slide(4);</p>
        <p>
          airline.slide(4, 7); //Does not return the last index and all method
          return a new string
        </p>
        <h3>Part 2</h3>
        <p>airline.toLowerCase();</p>
        <p>airline.toUpperCase();</p>
        <p>airline.trim(); // remove the blank space</p>
        <p>airline.replace('letter to replace', 'replace letter');</p>
        <p>airline.replaceAll(); // replace all letter</p>
        <p>
          using regular expression => airline.replace(/letter to replace/g,
          'replace letter');
        </p>
        <p>airline.includes('');</p>
        <p>airline.startsWith('');</p>
        <p>airline.endsWith();</p>
        <h3>Part 3</h3>
        <p>airline.split(' ') // return an array</p>
        <p>
          with Destructuring method => const [firstName, lastName] = 'Jonas
          Schedtmann'.split(' ');
        </p>
        <p>airline.join(' ')</p>
        <p>airline.padStart(25, '+') // add ++ before the element</p>
        <p>airline.padStart(23, '+') // add -- after the element</p>
        <p>airline.repeat(3) // repeat the string 3 times</p>
      </section>
    </div>

    <hr />

    <h2>section 10: A closer Look at Functions</h2>
    <div class="grid-form">
      <section>
        <h3>Default Parameters</h3>
        <p>
          const creatBooking = function (flightNum, numberPassengers = 100 ,
          price = 199){ const booking = { flightNum, numberPassengers, price };
          console.log(booking); }
        </p>
        <p>To skip an default value = put undefined</p>
        <p>example => createBooking('x', undefined, 1000)</p>
      </section>

      <section>
        <h3>How Passing Arguments works: value vs reference</h3>
        <p>
          Javascript does not have passing by reference, only passing by value
        </p>
      </section>

      <section>
        <h3>Fist-class and Higher-order functions</h3>
        <p>First-class functions</p>
        <p>Javascript treats function as first-class citizens</p>
        <p>This means that functions are simply values</p>
        <p>function are just another 'type' of object</p>
        <p>
          example => btnClose.addEventListener('click', functionName ); // pass
          function as arguments to other functions
        </p>

        <p>Higher-order functions</p>
        <p>
          A function that receives another function as an argument, that returns
          a new function, or both
        </p>
        <p>This is only possible because of first-class functions</p>
        <p>Function that returns new function</p>
      </section>

      <section>
        <h3>First Accepting callback functions</h3>
        <p>A function that accepts other functions as an input</p>
      </section>

      <section>
        <h3>Functions returning function</h3>
        <p>
          example => const greet = function (greeting) { return function (name)
          { console.log(`${greeting} ${name}`); }; };
        </p>
        <p>greet('hello')('Jonas')</p>
      </section>

      <section>
        <h3>The call and apply Methods (to review);</h3>
        <p><b>Call Methods</b></p>
        <p>book.call(eurowings, 23, 'sarah williams');</p>
        <p><b>Apply methods</b></p>
        <p>
          Does the same thing as call method but instead of receive a set of
          argument, it receive an array of argument
        </p>
      </section>

      <section>
        <h3>The bind Methods</h3>
        <p>const bookEW = book.bind(eurowings); // create a new function</p>
        <p>review it or read it</p>
      </section>

      <section>
        <h3>Immediately invoked function expression (IIFE)</h3>
        <p>(function runOnce(){ console.log('will run once'); })();</p>
      </section>

      <section>
        <h3>Closure</h3>
        <p>we don't create closures manually => happen automatically</p>
        <p>
          A closure is the closed-over variable environment of the execution
          context in which a function was created, even after that execution
          context is gone;
        </p>
      </section>
    </div>

    <hr />

    <h2>section 11: Working with Arrays</h2>
    <div class="grid-form">
      <section>
        <h3>Simple Array methods => a new array</h3>
        <p>Arrays are also an object</p>
        <p>=> <b>slice Method</b></p>
        <p>let arr = ['a', 'b', 'c', 'd', 'e']</p>
        <p>arr.slice(2, 4) => will not mutate the original one</p>
        <p>The length is (4-2): 2</p>
        <p>arr.slice() => can be use also as a shadow copy</p>

        <p>=> <b>Splice</b></p>
        <p>
          similar to slice but the different is that it mutate(change) the
          original array
        </p>

        <p>=> <b>Reverse</b></p>
        <p>It mutate the original array</p>

        <p>=> <b>Concat</b></p>
        <p>
          const letters = arr.concat(another array) => does not mutate the
          original array
        </p>

        <p>=> <b>Join method</b></p>
        <p>arr.join('-')</p>
      </section>

      <section>
        <h3>The new at methods</h3>
        <p>const arr = [23, 11, 64]</p>
        <p>console.log(arr.at(0)) //23</p>
        <p>refer at position 0</p>
        <p>arr.at(-1) => return the last element without bracket</p>
      </section>

      <section>
        <h3>Looping Arrays: forEach</h3>
        <p>const movements = [200, 450, -400, 3000, -650, -130, 70, 1300]</p>
        <p>
          movements.forEach(function(movement, index, array){
          console.log(movement, index, array) });
        </p>
        <p>
          always need to be first the current element | second the current index
          | third the array
        </p>
      </section>

      <section>
        <h3>forEach with Maps and Sets</h3>
        <p>
          const currrencies = new Map([ ['USD', 'United states dollar'], ['EUR',
          'Euro'], ['GBP', 'Pound sterling'] ]);
        </p>
        <p>currencies.forEach(function(value, key, map){})</p>
      </section>

      <section>
        <h3>Creating DOM Elements</h3>
        <p></p>
      </section>

      <section>
        <h3>Data Transformations: Map. Filter, reduce</h3>
        <p><b>The map Method</b></p>
        <p>
          Similar to for loop but the map methods returns a new array containing
          the results of applying an operation on all original array elements
        </p>
        <p>move.map(function(mov, i, array){ return mov * 0.1; });</p>

        <p><b>The filter Method</b></p>
        <p>
          filter returns a new array containing the array elements that passed a
          specified test condition
        </p>
        <p>move.filter(function(mov, i, arr){ return mov > 0; });</p>
        <p>
          if the condition is true, it will work other white it will be filter
          out
        </p>

        <p><b>The reduce Method</b></p>
        <p>
          reduce boils('reduces') all array elements down to one single value
          (e.g adding all elements together)
        </p>
        <p>
          const balance = movement.reduce(function(acc, cur, i, arr) { return
          acc + cir }, 0); // accumulator -> snowball // start at 0
        </p>
      </section>

      <section>
        <h3>The magic of chaining methods</h3>
        <p>
          const totalDepositsUSD = movement.filter(mov, i, arr).map().reduce();
        </p>
        <p>to check which methods has an erorr // console.log(arr)</p>
      </section>

      <section>
        <h3>The find method</h3>
        <p>movements.find(function(){ return mov < 0; });</p>
        <p>loop over the array and find an element</p>
        <p>
          Does not return a new array but will return the first element itself
          that satisfied the condition
        </p>
      </section>

      <section>
        <h3>The findIndex methods</h3>
        <p>
          same as find method but return the index of the element and not the
          element itself
        </p>
        <p>acc.findIndex(function(){ code here });</p>
      </section>

      <section>
        <h3>Some and every</h3>
        <p>movement.some(mov => mov > 0); // return true or false</p>
        <p></p>
        <p></p>
      </section>
    </div>

    <hr />

    <h2>section 12: Numbers, Dates, Intl and Timers</h2>
    <div class="grid-form">
      <section>
        <h3>Converting and Checking Number</h3>
        <p>Number is alway in floating number (decimal);</p>
        <p>Base 10 - 0 to 9</p>
        <p>Binary base 2 - 0 1</p>
        <p><b>Conversion</b></p>
        <p>add '+' to convert to number</p>
        <p>console.log(+'23') => output 23</p>
        <p><b>Parsing (remove unnecessary characters)</b></p>
        <p>console.log(Number.parsInt('30px', 10));</p>
        <p>console.log(Number.parsFloat('2.5rem', 10));</p>
        <p><b>check if it is non a number</b></p>
        <p>Number.isNaN('20');</p>
        <p><b>check if it is a number</b></p>
        <p>Number.isFinite('20'); outcome false</p>
        <p>Number.isInteger('20'); outcome false</p>
      </section>

      <section>
        <h3>Math and Rounding</h3>
        <p>Math.sqrt(25) outcome 5</p>
        <p>Math.max(5, 18, 23, 11, 2) outcome 23</p>
        <p>Math.min(5, 18, 23, 11, 2) outcome 2</p>
        <p>Math.PI</p>
        <p>Math.random() * 6</p>
        <p>Math.trunc() => remove the decimal part</p>
        <p>
          Example: const randomInt = (min, max) => Math.trunc(Math.random() *
          (max - min ) + 1 ) + min;
        </p>
        <p>Math.round(23.3);</p>
        <p>Math.ceil(23.9)</p>
        <p>Math.floor(23.0)</p>
        <p><b>Rounding decimals</b></p>
        <p>console.log((2.7).toFixed(0)) => will return a string</p>
        <p>console.log(+(2.7).toFixed(0)) => convert to number</p>
      </section>

      <section>
        <h3>The Remainder Operator</h3>
        <p>Example: console.log(3 % 2) outcome 1</p>
      </section>

      <section>
        <h3>Numeric Separators</h3>
        <p>const diameter = 287_460_000_000 => It is more clear</p>
      </section>

      <section>
        <h3>Working with BigInt</h3>
        <p>Re-watch if needed</p>
      </section>

      <section>
        <h3>Creating Date</h3>
        <p><b>create a date</b></p>
        <p>1. const newDate = new Date();</p>
        <p>2. new Date('Aug 02 2020');</p>
        <p>
          3. new Date(year, month, day, hours, mins, second) => (2022, 10, 20,
          10, 33, 40)
        </p>
        <p><b>working with date</b></p>
        <p>const future = new Date();</p>
        <p>future.getFullYear()</p>
        <p>future.getMonth()</p>
        <p>future.getDate()</p>
        <p>future.getDay()</p>
        <p>future.getHours()</p>
        <p>future.getMinutes()</p>
        <p>future.getSeconds()</p>
        <p>future.toISOString()</p>
      </section>

      <section>
        <h3>Operation with Dates</h3>
        <p>To review if needed</p>
      </section>

      <section>
        <h3>Timers: setTimeout and setInterval</h3>
        <p><b>setTimeout</b></p>
        <p>
          Example: <br />
          setTimeout((ing1, ing2) => console.log('Here is your pizza'), 3000,
          'olives, 'spinach');
          <br />
          note: element after the time delay is considerate as argument; note:
          clearTimeout
        </p>

        <p><b>setInterval</b></p>
        <p>
          setInterval(function(){ const now = new Date(); console.log(now) },
          1000)
        </p>
      </section>
    </div>

    <h2>section 13: Advanced Dom and events</h2>
    <div class="grid-form">
      <section>
        <h3>How the Dom really works</h3>
        <p>Allows us to make javascript interact with the browser;</p>
        <p>
          we can write javascript to create, modify and delete HTML elements;
        </p>
        <p>
          DOM tree is generated from an HTML document. which we can then
          interact with;
        </p>
        <p>
          DOM is a very complex API that contains lots of methods and properties
          to interact with the DOM tree
        </p>
      </section>

      <section>
        <h3>Selector, Creating, and Deleting Element</h3>
        <p><b>Selector element</b></p>
        <p>document.documentElement</p>
        <p>document.head</p>
        <p>document.body</p>
        <p>document.querySelector()</p>
        <p>document.getElementById()</p>
        <p>document.getElementsByTagName() => return an HTML collection</p>
        <p>document.getElementsByClassName();</p>

        <p><b>Creating element</b></p>
        <p>.insertAdjacentHTML</p>
        <p>document.createElement('div')</p>
        <p>add class => element.classlist.add('className')</p>
        <p>add text => element.textContent</p>
        <p>add html element => element.innerHTML();</p>
        <p>add to the DOM before the element selector => element.prepend()</p>
        <p>add to the DOM after the element selector => element.append()</p>
        <p>clone an element => element.cloneNode(true);</p>
        <p><u>Add the element as a sibling</u></p>
        <p>element.before()</p>
        <p>element.after()</p>

        <p>Deleting Element</p>
        <p>element.remove</p>
        <p>
          remove the child element" <br />
          element.parentElement.removeChild();
        </p>
      </section>

      <section>
        <h3>Style, Attribute, Classes</h3>
        <p><b>Style</b></p>
        <p>const element = document.querySelector();</p>
        <p><b>add inline style</b></p>
        <p>element.style.backgroundColor = red;</p>
        <p>
          get all the style of an element: <br />
          getComputedStyle(element);
        </p>
        <p><b>Attributes</b></p>
        <p>element.getAttribute('alt')</p>
        <p>element.setAttribute('company', 'Bankist')</p>
        <p>
          Data attribute: <br />
          element.dataSet.versionNumber <br />
          note in html => data-version-number = '3.0';
        </p>

        <p><b>classes</b></p>
        <p>element.classLis.add()</p>
        <p>element.classLis.remove()</p>
        <p>element.classLis.toggle()</p>
        <p>element.classLis.contains()</p>
      </section>

      <section>
        <h3>Types of events and event Handlers</h3>
        <p>h1.addEventListener('mouseover', function(){ code here });</p>
        <p>check other event on mdn website</p>
        <p><b>on event property</b></p>
        <p>
          h1.onmouseenter = function(e){ alert('onmouseenter: Great! You are
          reading the heading') }
        </p>
        <p>h1.removeEventListener();</p>
      </section>

      <section>
        <h3>Event Propagation: Bubbling and capturing</h3>
        <p><b>Stop propagation</b></p>
        <p>e.stopPropagation();</p>
      </section>

      <section>
        <h3>Event Delegation</h3>
      </section>

      <section>
        <h3>DOM traversing</h3>
        <p><b>Going downward: child</b></p>
        <p>h1.querySelectorAll('.highlight');</p>
        <p>console.log(h1.childNodes);</p>
        <p>console.log(h1.children); => direct children</p>
        <p>h1.firstElementChild => select the first child of the element</p>
        <p>h1.lastElementChild => select the last child of the element</p>
        <p><b>Going upwards: parents</b></p>
        <p>h1.parentNode => direct parent</p>
        <p>h1.parentElement</p>
        <p>h1.closest('.class');</p>
        <p><b>Going sideways: siblings</b></p>
        <p>h1.previousElementSibling</p>
        <p>h1.nextElementSibling</p>
      </section>

      <section>
        <h3>Lifecycle DOM Events</h3>
        <p>DOMContentLoaded</p>
      </section>

      <section>
        <h3>Efficient script loading: defer and async</h3>
        <p><b>Regular -> at the end of the body</b></p>
        <p>
          Scripts are fetched and executed after the HTML is completely parsed
        </p>
        <p><b>script async -> put in the header tag</b></p>
        <p>Scripts are fetched asynchronously and executed immediately</p>
        <p>
          Usually the DOMContentLoaded event waits for all scripts to execute,
          except for async scripts. So DOMContentLoaded does not wait for an
          async script
        </p>
        <p>Scripts not guaranteed to execute in order</p>
        <p>
          Use for 3rd-party scripts where order doesn't matter (e.g google
          Analytics)
        </p>
        <p><b>script defer -> put in the header tag => best way</b></p>
        <p>
          Scripts are fetched asynchronously and executed after the HTML is
          completely parsed
        </p>
        <p>DOMContentLoaded event fires after defer script is executed</p>
        <p>Scripts are executed in order</p>
        <p>
          This is overall the best solution! Use for your own scripts, and when
          order matters (e.g including a library)
        </p>
      </section>
    </div>

    <h2>section 14: Object-Oriented Programming (OOP) with Javascript</h2>
    <div class="grid-form">
      <section>
        <h3>What is Object-oriented programming?</h3>
        <p>
          Object-Oriented Programming (OOP) is a programming paradigm(style of
          code 'How' we write and organize code) base on the concept of objects;
        </p>
        <p>
          We use objects to model (describe) real world(e.g user) or abstract
          features(e.g data structure)
        </p>
        <p>
          Objects may contain data (properties and code (Methods).By using
          objects, we pack data and the corresponding behavior into a block)
        </p>
        <p>In OOP, objects are self-contained pieces / blocks of code</p>
        <p>
          Objects are building blocks of applications, and interact with one
          another
        </p>
        <p>
          Interactions happen through a public interface (API): methods that the
          code outside of the object can access and use to communicate with
          object;
        </p>
        <p>
          OOP was developed with the goal of organizing code, to make it more
          flexible and easier to maintain(avoid 'spaghetti code')
        </p>
        <p><b>The 4 fundamental principle of object-oriented programming</b></p>
        <p>1. Abstraction</p>
        <p>
          Abstraction: ignoring or hiding details that don't matter, allowing us
          to get an overview perspective of the thing we're implementing,
          instead of messing with details that don't really matter to our
          implementation
        </p>
        <p>2. Encapsulation</p>
        <p>
          Encapsulation: Keeping properties and method private inside the class,
          so they are not accessible from outside the class. Some methods can be
          exposed as public interface (API)
        </p>
        <p>3. inheritance</p>
        <p>
          Inheritance: Making all properties and methods of a certain class
          available to a child class, forming a hierarchical relationship
          between classes. This allows us to reuse common logic and to model
          real-world relationships.
        </p>
        <p>4. Polymorphism</p>
        <p>
          Polymorphism: A child class can over-write a method it inherited from
          a parent class [it's more complex that that, but enough for our
          purposes].
        </p>
      </section>

      <section>
        <h3>OOP in Javascript</h3>
        <p>Objects are linked to a prototype object</p>
        <p>
          Prototypal inheritance: The prototype contains methods (behavior) that
          are accessible to all objects linked to that prototype;
        </p>
        <p>Behavior is delegated to the linked prototype object</p>
        <p>3 ways of implementing prototypal inheritance in javascript</p>
        <p>1. Constructor function</p>
        <p>Technique to create objects from a function;</p>
        <p>
          This is how built-in objects like arrays, maps, or sets are actually
          implemented
        </p>
        <p>2. ES6 Classes</p>
        <p>Modern alternative to constructor function syntax</p>
        <p>ES6 classes do not behave like classes in 'classical OOP'</p>
        <p>3. Object.create()</p>
        <p>
          The easiest and most straightforward way of linking an object to a
          prototype object
        </p>
      </section>

      <section>
        <h3>Constructor functions and the new operator</h3>
        <p>Convention that constructor function start with a CAPITAL letter</p>
        <p>
          Arrow function does not work with constructor function because of
          'this' keyword
        </p>
        <p class="code-color">
          const Person = function (firstName, birthYear) { <br />
          this.firstName = firstName; <br />
          this.birthYear = birthYear; <br />
          }; <br /><br />
          const jonas = new person ('Jonas', 1991); console.log(jonas);
        </p>
        <p>=> process steps</p>
        <p>1. new {} is created</p>
        <p>2. function is called, this = {}</p>
        <p>3. {} linked to prototype</p>
        <p>4. function automatically return {}</p>
        <p>note that jonas is an instance of Person</p>
        <p>console.log (jonas instanceOF Person) outcome true</p>
        <p>Don't use method on a blue print => because it will copy it</p>
      </section>

      <section>
        <h3>Prototypes</h3>
        <p class="code-color">
          Person.prototype.calcAge = function () { <br />
          console.log(2027 - this.birthYear); <br />
          };
        </p>
        <p>console.log(jonas.__proto__);</p>
      </section>

      <section>
        <h3>Prototypal inheritance and the prototype chain</h3>
        <p>
          Prototype chian => series of links between objects, linked through
          prototypes
        </p>
        <p>To review if needed</p>
      </section>
      <section>
        <h3>Prototypal inheritance on built-in objects</h3>
        <p><b>prototype of an array</b></p>
        <p>const arr = [3, 4, 5, 6, 7]</p>
        <p>console.log(arr.__proto__);</p>
        <p>Add a new method to all array</p>
        <p>
          Array.prototype.unique = function () { return [...new Set(this)]; }
        </p>
        <p>
          console.dir(element) => allow me to view all method of this element
        </p>
      </section>

      <section>
        <h3>ES6 Classes</h3>
        <p class="code-color">
          class PersonCL { <br />
          constructor(firstName, birthYear){ <br />
          this.firstName = firstName; <br />
          this.birthYear = birthYear; <br />
          } calcAge() { <br />
          console.log(2027 - this birthYear); <br />
          } <br />

          greet() { <br />
          console.log() <br />
          } <br />
          }
        </p>

        <p>
          Noted: All method write in the class outside of the constructor will
          be on the prototype of the object and not on the object itself
        </p>

        <p class="code.color">
          PersonCL.prototype.greet = function() { <br />
          console.log('hello') };
        </p>

        <p>Points to be considered when using classes</p>
        <p>1. Classes are not hoisted</p>
        <p>
          2. Classes are first-class citizes => pass and return it as function
        </p>
        <p>3. Classes are executed in strict mode</p>
      </section>

      <section>
        <h3>Setters and Getters</h3>
        <p>
          Getters and setters are basically functions that get and set a value
        </p>
        <p>Any setter method needs to have exactly one parameter</p>
        <p class="code-color">
          const account = { <br />
          owner: 'jason', <br />
          movements: [200, 530, 130, 1230], <br /><br />

          get latest() { <br />
          return this.movements.slice(-1).pop(); <br />
          }, <br /><br />

          set latest(mov) { <br />
          this.movements.push(mov); }, <br />
          }
        </p>
        <p>console.log(account.latest) getter</p>
        <p>account.latest = 50 setter</p>
      </section>

      <section>
        <h3>Static Methods</h3>
        <p>To review if needed</p>
      </section>

      <section>
        <h3>Object.create</h3>
        <p>To review if needed</p>
      </section>

      <section>
        <h3>Inheritance between 'classes': constructor function</h3>
        <p>To review</p>
        <p>person.call()</p>
        <p>Student.prototype = Object.create(Person.prototype)</p>
      </section>

      <section>
        <h3>Inheritance between 'classes': ES6 classes</h3>
        <p class="code-color">
          class Student extends PersonCL { <br />
          constructor(FullName, birthYear, course) { <br />
          super(fullName, birthYear); // Always need to happen first <br />
          this.course = course; <br />
          } <br />
          }
        </p>
      </section>

      <section>
        <h3>Inheritance between 'classes': Object.create</h3>
        <p>To review if needed</p>
      </section>

      <section>
        <h3>Encapsulation: Protected properties and methods</h3>
        <p>
          It is important firstly to prevent code from outside of a class to
          accidentally manipulate or data inside the class
        </p>
        <p>to do this: add an underscore _ in front of the property name</p>
      </section>

      <section>
        <h3>Encapsulation: Private class fields and methods</h3>
      </section>

      <section>
        <h3>ES6 classes summary</h3>
        <p>To review it</p>
      </section>
    </div>

    <hr />

    <h2>section 14: Object-Oriented Programming (OOP) with Javascript</h2>
    <div class="grid-form">
      <section>
        <h3>How to plan a web project</h3>
        <p>Planning step</p>
        <p>1. user stories</p>
        <p>2. Features</p>
        <p>3. Flowchart</p>
        <p>4. Architecture</p>
        <p>Then Development step</p>

        <p><b>User stories</b></p>
        <p>
          Description of the application's functionality from the user's
          perspective. All user stories put together describe the entire
          application
        </p>
        <p>
          Common format: As a [type of user], I want [an action] so that [a
          benefit]
        </p>

        <p><b>Feature</b></p>
        <p>According to the user stories => we will develop the feature</p>

        <p><b>flowchart</b></p>
        <p>
          Whenever we start to build a flow chart like this, its a good idea to
          start with events
        </p>
        <p>e.g page loads</p>
      </section>
    </div>
    <hr />

    <h2>
      section 16: Asynchronous javascript: promises, Async/Await. and Ajax
    </h2>
    <div class="grid-form">
      <section>
        <h3>Asynchronous Javascript, AJAX and APIS</h3>
        <p><b>Synchronous</b></p>
        <p>Most code is synchronous;</p>
        <p>Synchronous code is executed line by line;</p>
        <p>Each line of code waits for previous line to finish;</p>
        <p>Long-running operations block code execution</p>
        <p><b>Asynchronous</b></p>
        <p>
          Asynchronous code is executed after a task that runs in the
          'background' finishes;
        </p>
        <p>Asynchronous code is non-blocking;</p>
        <p>
          Execution does't wait for an asynchronous task to finish its work;
        </p>

        <p><b>Ajax</b></p>
        <p>
          Asynchronous Javascript and Xml: Allows us to communicate with remove
          web servers in an asynchronous way. With AJAX call, we can request
          data from web serves dynamically
        </p>
        <p><b>API</b></p>
        <p>
          Application programming interface: Piece of software that can be used
          by another piece of software, in order to allow applications to talk
          to each other
        </p>
      </section>
    </div>

    <hr />

    <h2>
      section 17: modern javascript development: modules, Tooling, and
      functional
    </h2>
    <div class="grid-form">
      <section>
        <h3>Modern Javascript Development</h3>
        <p>Bundling -> Join all modules into one file</p>
        <p>
          Transpiling / Polyfilling -> convert modern javascript back to ES5
        </p>
      </section>

      <section>
        <h3>An overview of modules in javascript</h3>
        <p>
          module -> Reusable piece of code that encapsulates implementation
          details
        </p>
        <p>Usually a standalone file, but it doesn't have to be</p>
        <p><b>advantage of using module</b></p>
        <p>
          1. Compose software: Modules are small building blocks that we put
          together to build complex applications
        </p>
        <p>
          2. Isolate components: Modules can be developed om isolation without
          thinking about the entire codebase
        </p>
        <p>
          3. Abstract code: implement low-level code in modules and import these
          abstractions into other modules
        </p>
        <p>
          4. Organized code: Modules naturally lead to a more organize codebase
        </p>
        <p>
          5. Reuse code: Modules allow us to easily reuse the same code, even
          across multiple projects
        </p>
      </section>

      <section>
        <h3>Exporting and importing in ES6 Modules</h3>
        <p>script type='module'</p>
        <p>To import -> import './fileName.js'</p>
        <p>To review when we export module</p>
      </section>

      <section>
        <h3>Top-level await (ES2022)</h3>
        <p></p>
      </section>

      <section>
        <h3>The Module Patten</h3>
        <p>
          The main goal of the module pattern is to encapsulate functionality,
          to have private data, and to expose a public API
        </p>
        <p>we can achieve this by using a function</p>
      </section>

      <section>
        <h3>A Brief introduction to the command Line</h3>
        <p>ls -> show all files in the folder</p>
        <p>cd [Change directory] -> change folder</p>
        <p>mkdir nameFile -> create folder with the name of nameFile</p>
        <p>touch index.html -> create an html file</p>
        <p>ctrl + c -> end thing or exit</p>
        <p>rm/del index.html -> delete file</p>
        <p>
          mv index.html parent-folder-> move file => index.html to parent-folder
        </p>
        <p>rmdir -> remove folder</p>
      </section>

      <section>
        <h3>Introduction to NPM</h3>
        <p></p>
      </section>
    </div>

    <hr />

    <h2>section 19: Setting up Git and Deployment</h2>
    <div class="grid-form">
      <section>
        <h3>Simple Deployment with Netlify</h3>
        <p></p>
      </section>

      <section>
        <h3>Setting up git and github</h3>
      </section>
    </div>

    <hr />

    <h2>Other useful information</h2>
    <div class="grid-form">
      <section>
        <h3>HTMLElement.offsetHeight</h3>
        <p>
          read-only property returns the height of an element, including
          vertical padding and border, as an integer
        </p>
      </section>
    </div>
  </body>
</html>
